/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./main.ts":
/*!*****************!*\
  !*** ./main.ts ***!
  \*****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var elix_src_Button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! elix/src/Button.js */ \"./node_modules/elix/src/Button.js\");\n/* harmony import */ var elix_src_symbols_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! elix/src/symbols.js */ \"./node_modules/elix/src/symbols.js\");\n\n// import { Button } from 'elix';\n\nconst button = new elix_src_Button_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n// button.textContent = 'Hello';\ndocument.body.appendChild(button);\nbutton.inner.textContent = 'Goodbye';\nconst delegatesFocus = button[elix_src_symbols_js__WEBPACK_IMPORTED_MODULE_1__[\"delegatesFocus\"]];\nconsole.log(delegatesFocus);\nconst s = Symbol();\nbutton[s] = 'hello';\nconsole.log(button[s]);\n\n\n//# sourceURL=webpack:///./main.ts?");

/***/ }),

/***/ "./node_modules/elix/src/AriaRoleMixin.js":
/*!************************************************!*\
  !*** ./node_modules/elix/src/AriaRoleMixin.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AriaRoleMixin; });\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbols.js */ \"./node_modules/elix/src/symbols.js\");\n\n\n\n/**\n * Lets a component define its ARIA role through a `role` state member\n * \n * Among other things, this allows a class or mixin to define a default\n * role through the component's `defaultState`.\n * \n * Some mixins come with identicial support for managing an ARIA role. Those\n * mixins include [AriaListMixin](AriaListMixin),\n * [AriaMenuMixin](AriaMenuMixin), [DialogModalityMixin](DialogModalityMixin),\n * and [PopupModalityMixin](PopupModalityMixin). If you're using one of those\n * mixins, you do *not* need to use this mixin.\n *\n * @module AriaRoleMixin\n */\nfunction AriaRoleMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class AriaRole extends Base {\n\n    [_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]](changed) {\n      if (super[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]]) { super[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]](changed); }\n      if (changed.role) {\n        // Apply top-level role.\n        const { role } = this.state;\n        this.setAttribute('role', role);\n      }\n    }\n\n    // Setting the standard role attribute will invoke this property setter,\n    // which will allow us to update our state.\n    get role() {\n      return super.role;\n    }\n    set role(role) {\n      super.role = role;\n      if (!this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"rendering\"]]) {\n        this.setState({\n          role\n        });\n      }\n    }\n\n  }\n\n  return AriaRole;\n}\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/AriaRoleMixin.js?");

/***/ }),

/***/ "./node_modules/elix/src/AttributeMarshallingMixin.js":
/*!************************************************************!*\
  !*** ./node_modules/elix/src/AttributeMarshallingMixin.js ***!
  \************************************************************/
/*! exports provided: booleanAttributes, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"booleanAttributes\", function() { return booleanAttributes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AttributeMarshallingMixin; });\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbols.js */ \"./node_modules/elix/src/symbols.js\");\n\n\n\nconst booleanAttributes = {\n  checked: true,\n  defer: true,\n  disabled: true,\n  hidden: true,\n  ismap: true,\n  multiple: true,\n  noresize: true,\n  readonly: true,\n  selected: true\n};\n\n\n// Memoized maps of attribute to property names and vice versa.\n// We initialize this with the special case of the tabindex (lowercase \"i\")\n// attribute, which is mapped to the tabIndex (capital \"I\") property.\nconst attributeToPropertyNames = {\n  tabindex: 'tabIndex'\n};\nconst propertyNamesToAttributes = {\n  tabIndex: 'tabindex'\n};\n\n\n/**\n * Sets properties when corresponding attributes change.\n *\n * If your component exposes a setter for a property, it's generally a good\n * idea to let devs using your component be able to set that property in HTML\n * via an element attribute. You can code that yourself by writing an\n * `attributeChangedCallback`, or you can use this mixin to get a degree of\n * automatic support.\n *\n * This mixin implements an `attributeChangedCallback` that will attempt to\n * convert a change in an element attribute into a call to the corresponding\n * property setter. Attributes typically follow hyphenated names (\"foo-bar\"),\n * whereas properties typically use camelCase names (\"fooBar\"). This mixin\n * respects that convention, automatically mapping the hyphenated attribute\n * name to the corresponding camelCase property name.\n *\n * Example: You define a component using this mixin:\n *\n *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {\n *       get fooBar() { return this._fooBar; }\n *       set fooBar(value) { this._fooBar = value; }\n *     }\n *     customElements.define('my-element', MyElement);\n *\n * If someone then instantiates your component in HTML:\n *\n *     <my-element foo-bar=\"Hello\"></my-element>\n *\n * Then, after the element has been upgraded, the `fooBar` setter will\n * automatically be invoked with the initial value \"Hello\".\n *\n * Attributes can only have string values. If you'd like to convert string\n * attributes to other types (numbers, booleans), you must implement parsing\n * yourself.\n *\n * @module AttributeMarshallingMixin\n */\nfunction AttributeMarshallingMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class AttributeMarshalling extends Base {\n\n    // Handle a change to the attribute with the given name.\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) {\n        super.attributeChangedCallback(attributeName, oldValue, newValue);\n      }\n      // Sometimes there's not actually any change.\n      // We also skip setting properties if we're rendering. A component\n      // may want to reflect property values to attributes during rendering,\n      // but such attribute changes shouldn't trigger property updates.\n      if (newValue !== oldValue && !this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"rendering\"]]) {\n        const propertyName = attributeToPropertyName(attributeName);\n        // If the attribute name corresponds to a property name, set the property.\n        if (propertyName in this) {\n          this[propertyName] = castPotentialBooleanAttribute(attributeName, newValue);\n        }\n      }\n    }\n\n    static get observedAttributes() {\n      /** @type {any} */\n      const elementClass = this;\n      return attributesForClass(elementClass);\n    }\n\n  }\n\n  return AttributeMarshalling;\n}\n\n\n// Return the custom attributes for the given class.\nfunction attributesForClass(classFn) {\n\n  // We treat the HTMLElement base class as if it has no attributes, since we\n  // don't want to receive attributeChangedCallback for it.\n  if (classFn === HTMLElement) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n  // See if parent class defines observedAttributes manually.\n  let baseAttributes = baseClass.observedAttributes;\n  if (!baseAttributes) {\n    // Calculate parent class attributes ourselves.\n    baseAttributes = attributesForClass(baseClass);\n  }\n\n  // Get attributes for this class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter(propertyName => {\n    const descriptor = Object.getOwnPropertyDescriptor(classFn.prototype, propertyName);\n    return descriptor && typeof descriptor.set === 'function';\n  });\n  const attributes = setterNames.map(setterName =>\n      propertyNameToAttribute(setterName));\n\n  // Merge.\n  const diff = attributes.filter(attribute =>\n      baseAttributes.indexOf(attribute) < 0);\n  const result = baseAttributes.concat(diff);\n\n  // Remove standard `style` property.\n  const styleIndex = result.indexOf('style');\n  if (styleIndex >= 0) {\n    result.splice(styleIndex, 1);\n  }\n  return result;\n}\n\n\n// Convert hyphenated foo-bar attribute name to camel case fooBar property name.\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hyphenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hyphenRegEx,\n        match => match[1].toUpperCase());\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\n\n// If the given attribute name corresponds to a boolean attribute,\n// map the supplied string value to a boolean. Otherwise return as is.\nfunction castPotentialBooleanAttribute(attributeName, value) {\n  if (booleanAttributes[attributeName]) {\n    if (typeof value === 'string') {\n      return true;\n    } else if (value === null) {\n      return false;\n    }\n  }\n  return value;\n}\n\n\n// Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, '-$1').toLowerCase();\n  }\n  return attribute;\n}\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/AttributeMarshallingMixin.js?");

/***/ }),

/***/ "./node_modules/elix/src/Button.js":
/*!*****************************************!*\
  !*** ./node_modules/elix/src/Button.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbols.js */ \"./node_modules/elix/src/symbols.js\");\n/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./template.js */ \"./node_modules/elix/src/template.js\");\n/* harmony import */ var _AriaRoleMixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AriaRoleMixin.js */ \"./node_modules/elix/src/AriaRoleMixin.js\");\n/* harmony import */ var _ComposedFocusMixin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ComposedFocusMixin.js */ \"./node_modules/elix/src/ComposedFocusMixin.js\");\n/* harmony import */ var _FocusVisibleMixin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FocusVisibleMixin.js */ \"./node_modules/elix/src/FocusVisibleMixin.js\");\n/* harmony import */ var _KeyboardMixin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./KeyboardMixin.js */ \"./node_modules/elix/src/KeyboardMixin.js\");\n/* harmony import */ var _WrappedStandardElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WrappedStandardElement.js */ \"./node_modules/elix/src/WrappedStandardElement.js\");\n\n\n\n\n\n\n\n\n\nconst Base =\n  Object(_AriaRoleMixin_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  Object(_ComposedFocusMixin_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n  Object(_FocusVisibleMixin_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(\n  Object(_KeyboardMixin_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(\n    _WrappedStandardElement_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].wrap('button')\n  ))));\n\n\n// Do we need to explicitly map Space/Enter keys to a button click?\n//\n// As of February 2019, Firefox automatically translates a Space/Enter key on a\n// button into a click event that bubbles to its host. Chrome/Safari do not do\n// this automatically, so we have to do it ourselves.\n//\n// It's gross to look for a specific browser (Firefox), but it seems extremely\n// hard to feature-detect this. Even if we try to create a button in a shadow at\n// runtime and send a key event to it, Chrome/Safari don't seem to do their\n// normal mapping of Space/Enter to a click for synthetic keyboard events.\n//\n// Firefox detection adapted from https://stackoverflow.com/a/9851769/76472\n// and adjusted to pass type checks.\nconst firefox = 'InstallTrigger' in window;\nconst mapKeysToClick = !firefox;\n\n\n/**\n * Base class for custom buttons.\n * \n * `Button` wraps a standard HTML `button` element, allowing for custom styling\n * and behavior while ensuring standard keyboard and focus behavior.\n * \n * @inherits WrappedStandardElement\n * @mixes AriaRoleMixin\n * @mixes ComposedFocusMixin\n * @mixes FocusVisibleMixin\n * @mixes KeyboardMixin\n */\nclass Button extends Base {\n\n  get defaultState() {\n    return Object.assign(super.defaultState, {\n      role: 'button',\n      treatEnterAsClick: true,\n      treatSpaceAsClick: true\n    });\n  }\n\n  // Pressing Enter or Space raises a click event, as if the user had clicked\n  // the inner button.\n  // TODO: Space should raise the click on *keyup*.\n  [_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"keydown\"]](event) {\n    let handled;\n    if (mapKeysToClick) {\n      switch (event.key) {\n        case ' ':\n          if (this.state.treatSpaceAsClick) {\n            this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"tap\"]]();\n            handled = true;\n          }\n          break;\n\n        case 'Enter':\n          if (this.state.treatEnterAsClick) {\n            this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"tap\"]]();\n            handled = true;\n          }\n          break;\n      }\n    }\n\n    // Prefer mixin result if it's defined, otherwise use base result.\n    return handled || (super[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"keydown\"]] && super[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"keydown\"]](event));\n  }\n\n  [_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]](changed) {\n    super[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]](changed);\n    if (changed.focusVisible) {\n      // Override host `outline` style supplied by FocusVisibleMixin.\n      this.style.outline = 'none';\n      const { focusVisible } = this.state;\n      this.$.inner.style.outline = focusVisible ? '' : 'none';\n    }\n  }\n\n  // Respond to a simulated click.\n  [_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"tap\"]]() {\n    const clickEvent = new MouseEvent('click');\n    this.dispatchEvent(clickEvent);\n  }\n\n  get [_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"template\"]]() {\n    return _template_js__WEBPACK_IMPORTED_MODULE_1__[\"html\"]`\n      <style>\n        :host {\n          display: inline-flex;\n          outline: none;\n          -webkit-tap-highlight-color: transparent;\n          touch-action: manipulation;\n        }\n        \n        #inner {\n          align-items: center; /* Edge */\n          color: inherit;\n          display: inline-flex;\n          flex: 1;\n          font-family: inherit;\n          font-size: inherit;\n          font-style: inherit;\n          font-weight: inherit;\n          height: 100%;\n          justify-content: center;\n          padding: 0;\n          position: relative;\n          text-align: initial; /* Edge */\n          width: 100%;\n        }\n      </style>\n\n      <button id=\"inner\" role=\"none\">\n        <slot></slot>\n      </button>\n    `;\n  }\n\n}\n\n\ncustomElements.define('elix-button', Button);\n/* harmony default export */ __webpack_exports__[\"default\"] = (Button);\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/Button.js?");

/***/ }),

/***/ "./node_modules/elix/src/ComposedFocusMixin.js":
/*!*****************************************************!*\
  !*** ./node_modules/elix/src/ComposedFocusMixin.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ComposedFocusMixin; });\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities.js */ \"./node_modules/elix/src/utilities.js\");\n\n\n\n// Quick detection of whether we'll need to handle focus.\n// As of February 2019, we don't need to handle this in Chrome, perhaps because\n// they already support delegatesFocus (which handles related focus issues).\nconst focusTest = document.createElement('div');\nfocusTest.attachShadow({ mode: 'open', delegatesFocus: true });\n/** @type {any} */\nconst shadowRoot = focusTest.shadowRoot;\nconst nativeDelegatesFocus = shadowRoot.delegatesFocus;\n\n\n/**\n * Normalizes focus treatment for custom elements with Shadow DOM\n * \n * This mixin exists because the default behavior for mousedown should set the\n * focus to the closest ancestor of the clicked element that can take the focus.\n * As of Nov 2018, Chrome and Safari don't handle this as expected when the\n * clicked element is reassigned across more than one slot to end up inside a\n * focusable element. In such cases, the focus will end up on the body. Firefox\n * exhibits the behavior we want. See\n * https://github.com/w3c/webcomponents/issues/773.\n *\n * This mixin normalizes behavior to provide what Firefox does. When the user\n * mouses down inside anywhere inside the component's light DOM or Shadow DOM,\n * we walk up the composed tree to find the first element that can take the\n * focus and put the focus on it.\n * \n * @module ComposedFocusMixin\n */\nfunction ComposedFocusMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class ComposedFocus extends Base {\n\n    componentDidMount() {\n      if (super.componentDidMount) { super.componentDidMount(); }\n      this.addEventListener('mousedown', event => {\n        if (!this.state.composeFocus) {\n          return;\n        }\n        // Only process events for the main (usually left) button.\n        if (event.button !== 0) {\n          return;\n        }\n        const target = Object(_utilities_js__WEBPACK_IMPORTED_MODULE_0__[\"closestFocusableAncestor\"])(event.target);\n        if (target) {\n          target.focus();\n          event.preventDefault();\n        }\n      });\n    }\n\n    get defaultState() {\n      return Object.assign(super.defaultState, {\n        composeFocus: !nativeDelegatesFocus\n      });\n    }\n\n  }\n\n  return ComposedFocus;\n}\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/ComposedFocusMixin.js?");

/***/ }),

/***/ "./node_modules/elix/src/DelegateFocusMixin.js":
/*!*****************************************************!*\
  !*** ./node_modules/elix/src/DelegateFocusMixin.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DelegateFocusMixin; });\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities.js */ \"./node_modules/elix/src/utilities.js\");\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbols.js */ \"./node_modules/elix/src/symbols.js\");\n\n\n\n\n/**\n * Delegates a component's focus to its first focusable shadow element.\n * \n * This mixin serves as a polyfill for the standard `delegatesFocus` shadow\n * root property. As of April 2019, that property is only supported in Chrome.\n * \n * @module DelegateFocusMixin\n */\nfunction DelegateFocusMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class DelegateFocus extends Base {\n\n    componentDidMount() {\n      if (super.componentDidMount) { super.componentDidMount(); }\n      // The delegatesFocus spec says that the focus outline should be shown on\n      // both the host and the focused subelement — which seems confusing and\n      // (in our opinion) looks ugly. If the browser supports delegatesFocus we\n      // suppress the host focus outline.\n      if (this.shadowRoot.delegatesFocus) {\n        this.style.outline = 'none';\n      }\n    }\n\n    /**\n     * Returns true if the component is delegating its focus.\n     * \n     * A component using `DelegateFocusMixin` will always have this property be\n     * true unless a class takes measures to override it.\n     * \n     * @type {boolean}\n     * @default true\n     */\n    get [_symbols_js__WEBPACK_IMPORTED_MODULE_1__[\"delegatesFocus\"]]() {\n      return true;\n    }\n\n    // If someone tries to put the focus on us, delegate the focus to the first\n    // focusable element in the composed tree below our shadow root.\n    focus(focusOptions) {\n      if (this.shadowRoot.delegatesFocus) {\n        // Native support for delegatesFocus, so don't need to do anything.\n        super.focus(focusOptions);\n        return;\n      }\n      const focusElement = this[_symbols_js__WEBPACK_IMPORTED_MODULE_1__[\"focusTarget\"]];\n      if (focusElement) {\n        focusElement.focus(focusOptions);\n      }\n    }\n\n    get [_symbols_js__WEBPACK_IMPORTED_MODULE_1__[\"focusTarget\"]]() {\n      return this.shadowRoot.delegatesFocus ?\n        this :\n        Object(_utilities_js__WEBPACK_IMPORTED_MODULE_0__[\"firstFocusableElement\"])(this.shadowRoot);\n    }\n\n  }\n\n  return DelegateFocus;\n\n}\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/DelegateFocusMixin.js?");

/***/ }),

/***/ "./node_modules/elix/src/FocusVisibleMixin.js":
/*!****************************************************!*\
  !*** ./node_modules/elix/src/FocusVisibleMixin.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return FocusVisibleMixin; });\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities.js */ \"./node_modules/elix/src/utilities.js\");\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbols.js */ \"./node_modules/elix/src/symbols.js\");\n\n\n\n\n// We consider the keyboard to be active if the window has received a keydown\n// event since the last mousedown event.\nlet keyboardActive = false;\n\n/** @type {any} */\nconst focusVisibleChangedListenerKey = Symbol('focusVisibleChangedListener');\n\n\n/**\n * Shows a focus indication if and only if the keyboard is active.\n * \n * The keyboard is considered to be active if a keyboard event has occurred\n * since the last mousedown event.\n * \n * This is loosely modeled after the proposed\n * [focus-visible](https://github.com/WICG/focus-visible) feature for CSS.\n * \n * @module FocusVisibleMixin\n */\nfunction FocusVisibleMixin(Base) {\n\n  // The class prototype added by the mixin.\n  return class FocusVisible extends Base {\n\n    constructor() {\n      // @ts-ignore\n      super();\n\n      // We listen to focusin/focusout instead of focus/blur because components\n      // like Menu want to handle focus visiblity for the items they contain,\n      // and those contained items can get the focus. Using focusin/focusout\n      // lets us know whether this element *or any element it contains* has the\n      // focus.\n      //\n      // Focus events are problematic in that they can occur during rendering:\n      // if an element with the focus is updated so that its tabindex is\n      // removed, it will lose focus. Since these focus handlers need to set\n      // state, this could lead to setting state during rendering, which is bad.\n      // To avoid this problem, we use promise timing to defer the setting of\n      // state.\n      this.addEventListener('focusout', event => {\n        Promise.resolve().then(() => {\n          // What has the focus now?\n          const newFocusedElement = event.relatedTarget || document.activeElement;\n          const isFocusedElement = this === newFocusedElement;\n          /** @type {any} */\n          const cast = this;\n          const containsFocus = Object(_utilities_js__WEBPACK_IMPORTED_MODULE_0__[\"deepContains\"])(cast, newFocusedElement);\n          const lostFocus = !isFocusedElement && !containsFocus;\n          if (lostFocus) {\n            this.setState({\n              focusVisible: false\n            });\n            // No longer need to listen for changes in focus visibility.\n            document.removeEventListener('focus-visible-changed',\n              this[focusVisibleChangedListenerKey]);\n            this[focusVisibleChangedListenerKey] = null;\n          }\n        });\n      });\n      this.addEventListener('focusin', () => {\n        Promise.resolve().then(() => {\n          if (this.state.focusVisible !== keyboardActive) {\n            // Show the element as focused if the keyboard has been used.\n            this.setState({\n              focusVisible: keyboardActive\n            });\n          }\n          if (!this[focusVisibleChangedListenerKey]) {\n            // Listen to subsequent changes in focus visibility.\n            this[focusVisibleChangedListenerKey] = () => refreshFocus(this);\n            document.addEventListener('focus-visible-changed',\n              this[focusVisibleChangedListenerKey]);\n          }\n        });\n      });\n    }\n\n    get defaultState() {\n      return Object.assign(super.defaultState, {\n        focusVisible: false\n      });\n    }\n\n    [_symbols_js__WEBPACK_IMPORTED_MODULE_1__[\"render\"]](changed) {\n      if (super[_symbols_js__WEBPACK_IMPORTED_MODULE_1__[\"render\"]]) { super[_symbols_js__WEBPACK_IMPORTED_MODULE_1__[\"render\"]](changed); }\n      if (changed.focusVisible) {\n        // Suppress the component's normal `outline` style unless we know the\n        // focus should be visible.\n        this.style.outline = this.state.focusVisible ? '' : 'none';\n      }\n    }\n\n    /**\n     * Temporarily suppress visibility of the keyboard focus until the next\n     * keydown event.\n     * \n     * This can be useful in components like [Menu](Menu) that actively manage\n     * where the focus is in response to mouse hover activity. If the user uses\n     * the keyboard to invoke a menu, then changes to using the mouse, it can be\n     * distracting to see the focus indicator moving as well. In such\n     * situations, the component can invoke this method (e.g., in response to\n     * `mousemove`) to temporarily suppress focus visibility.\n     */\n    suppressFocusVisibility() {\n      keyboardActive = false;\n      refreshFocus(this);\n    }\n  }\n}\n\n\nfunction refreshFocus(element) {\n  element.setState({\n    focusVisible: keyboardActive\n  });\n}\n\n\nfunction updateKeyboardActive(newKeyboardActive) {\n  if (keyboardActive !== newKeyboardActive) {\n    keyboardActive = newKeyboardActive;\n    const event = new CustomEvent('focus-visible-changed', {\n      detail: {\n        focusVisible: keyboardActive\n      }\n    });\n    document.dispatchEvent(event);\n  }\n}\n\n\n// Listen for top-level keydown and mousedown events.\n// Use capture phase so we detect events even if they're handled.\nwindow.addEventListener('keydown', () => {\n  updateKeyboardActive(true);\n}, { capture: true });\n\nwindow.addEventListener('mousedown', () => {\n  updateKeyboardActive(false);\n}, { capture: true });\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/FocusVisibleMixin.js?");

/***/ }),

/***/ "./node_modules/elix/src/KeyboardMixin.js":
/*!************************************************!*\
  !*** ./node_modules/elix/src/KeyboardMixin.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return KeyboardMixin; });\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbols.js */ \"./node_modules/elix/src/symbols.js\");\n\n\n\n/**\n * Manages keyboard handling for a component.\n *\n * This mixin handles several keyboard-related features.\n *\n * First, it wires up a single keydown event handler that can be shared by\n * multiple mixins on a component. The event handler will invoke a `keydown`\n * method with the event object, and any mixin along the prototype chain that\n * wants to handle that method can do so.\n *\n * If a mixin wants to indicate that keyboard event has been handled, and that\n * other mixins should *not* handle it, the mixin's `keydown` handler should\n * return a value of true. The convention that seems to work well is that a\n * mixin should see if it wants to handle the event and, if not, then ask the\n * superclass to see if it wants to handle the event. This has the effect of\n * giving the mixin that was applied last the first chance at handling a\n * keyboard event.\n *\n * Example:\n *\n *     [symbols.keydown](event) {\n *       let handled;\n *       switch (event.key) {\n *         // Handle the keys you want, setting handled = true if appropriate.\n *       }\n *       // Prefer mixin result if it's defined, otherwise use base result.\n *       return handled || (super[symbols.keydown] && super[symbols.keydown](event));\n *     }\n *\n * A second feature provided by this mixin is that it implicitly makes the\n * component a tab stop if it isn't already, by setting `tabindex` to 0. This\n * has the effect of adding the component to the tab order in document order.\n *\n * @module KeyboardMixin\n */\nfunction KeyboardMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class Keyboard extends Base {\n\n    constructor() {\n      // @ts-ignore\n      super();\n      this.addEventListener('keydown', async (event) => {\n        this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"raiseChangeEvents\"]] = true;\n        // For use with FocusVisibleMixin.\n        if (!this.state.focusVisible) {\n          // The user may have begun interacting with this element using the\n          // mouse/touch, but has now begun using the keyboard, so show focus.\n          this.setState({\n            focusVisible: true\n          });\n        }\n        const handled = this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"keydown\"]](event);\n        if (handled) {\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        }\n        await Promise.resolve();\n        this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"raiseChangeEvents\"]] = false;\n      });\n    }\n\n    get defaultState() {\n      // If we're using DelegateFocusMixin, we don't need or want to set a\n      // tabindex on the host; we'll rely on the inner shadow elements to take\n      // the focus and raise keyboard events. Otherwise, we do set a tabindex on\n      // the host, so that we can get keyboard events.\n      const tabIndex = this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"delegatesFocus\"]] ? null : 0;\n      const state = Object.assign(super.defaultState, {\n        tabIndex\n      });\n\n      return state;\n    }\n    \n    /**\n     * See the [symbols](symbols#keydown) documentation for details.\n     */\n    [_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"keydown\"]](event) {\n      if (super[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"keydown\"]]) { return super[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"keydown\"]](event); }\n      return false;\n    }\n\n    [_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]](changed) {\n      if (super[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]]) { super[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]](changed); }\n      if (changed.tabIndex) {\n        this.tabIndex = this.state.tabIndex;\n      }\n    }\n\n    // Record our own notion of the state of the tabIndex property so we can\n    // rerender if necessary.\n    get tabIndex() {\n      return super.tabIndex;\n    }\n    set tabIndex(tabIndex) {\n      // Parse the passed value, which could be a string or null.\n      let parsed = tabIndex !== null ? Number(tabIndex) : null;\n      if (parsed !== null && isNaN(parsed)) {\n        const defaultTabIndex = this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"defaultTabIndex\"]];\n        parsed = defaultTabIndex ? defaultTabIndex : 0;\n      }\n\n      // If parsed value isn't null and has changed, invoke the super setter.\n      if (parsed !== null && super.tabIndex !== parsed) {\n        super.tabIndex = parsed;\n      }\n\n      // The tabIndex setter can get called during rendering when we render our\n      // own notion of the tabIndex state, in which case we don't need or want\n      // to set state again.\n      if (!this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"rendering\"]]) {\n        // Record the new tabIndex in our state.\n        this.setState({\n          tabIndex: parsed\n        });\n      }\n    }\n\n  }\n\n  return Keyboard;\n}\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/KeyboardMixin.js?");

/***/ }),

/***/ "./node_modules/elix/src/ReactiveElement.js":
/*!**************************************************!*\
  !*** ./node_modules/elix/src/ReactiveElement.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _AttributeMarshallingMixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AttributeMarshallingMixin.js */ \"./node_modules/elix/src/AttributeMarshallingMixin.js\");\n/* harmony import */ var _ReactiveMixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReactiveMixin.js */ \"./node_modules/elix/src/ReactiveMixin.js\");\n/* harmony import */ var _ShadowTemplateMixin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShadowTemplateMixin.js */ \"./node_modules/elix/src/ShadowTemplateMixin.js\");\n\n\n\n\n\n/**\n * General-purpose base for writing components in functional-reactive style\n * \n * This base class lets you create web components in a functional-reactive\n * programming (FRP) style. It simply bundles a small set of mixins:\n *\n *     const ReactiveElement =\n *       AttributeMarshallingMixin(\n *       ReactiveMixin(\n *       ShadowTemplateMixin(\n *         HTMLElement\n *       )))));\n *\n * `ReactiveElement` is provided as a convenience. You can achieve the same\n * result by applying the mixins yourself to `HTMLElement`.\n * \n * @inherits HTMLElement\n * @mixes AttributeMarshallingMixin\n * @mixes ReactiveMixin\n * @mixes ShadowTemplateMixin\n */\nconst ReactiveElement =\n  Object(_AttributeMarshallingMixin_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\n  Object(_ReactiveMixin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n  Object(_ShadowTemplateMixin_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n    HTMLElement\n  )));\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ReactiveElement);\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/ReactiveElement.js?");

/***/ }),

/***/ "./node_modules/elix/src/ReactiveMixin.js":
/*!************************************************!*\
  !*** ./node_modules/elix/src/ReactiveMixin.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ReactiveMixin; });\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbols.js */ \"./node_modules/elix/src/symbols.js\");\n/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./State.js */ \"./node_modules/elix/src/State.js\");\n\n\n\n\n/** @type {any} */\nconst mountedKey = Symbol('mounted');\n/** @type {any} */\nconst stateKey = Symbol('state');\n/** @type {any} */\nconst raiseChangeEventsInNextRenderKey = Symbol('raiseChangeEventsInNextRender');\n\n\n// Tracks total set of changes made to elements since their last render.\nconst changedSinceLastRender = new WeakMap();\n\n\n/**\n * Manages component state and renders changes in state\n * \n * This is modeled after React/Preact's state management, and is adapted for\n * use with web components. Applying this mixin to a component will give it\n * FRP behavior comparable to React's.\n * \n * @module ReactiveMixin\n */\nfunction ReactiveMixin(Base) {\n  return class Reactive extends Base {\n\n    constructor() {\n      // @ts-ignore\n      super();\n      // Set the initial state from the default state defined by the component\n      // and its mixins.\n      this.setState(this.defaultState);\n    }\n\n    componentDidMount() {\n      if (super.componentDidMount) { super.componentDidMount(); }\n    }\n\n    componentDidUpdate(changed) {\n      if (super.componentDidUpdate) { super.componentDidUpdate(changed); }\n    }\n\n    connectedCallback() {\n      if (super.connectedCallback) { super.connectedCallback(); }\n      // Render the component. If the component was forced to render before this\n      // point, and the state hasn't changed, this call will be a no-op.\n      this.render();\n    }\n\n    /**\n     * The default state for the component. This can be extended by mixins and\n     * classes to provide additional default state.\n     * \n     * @type {State}\n     */\n    get defaultState() {\n      return new _State_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    }\n\n    /**\n     * Render pending component changes to the DOM.\n     * \n     * This method does nothing if the state has not changed since the last\n     * render call.\n     * \n     * This method invokes all internal render methods. It then invoked\n     * `componentDidMount` (for first render) or `componentDidUpdate` (for\n     * subsequent renders).\n     */\n    render() {\n\n      // Determine what's changed since the last render.\n      const changed = changedSinceLastRender.get(this);\n\n      // We only render if the component's never been rendered before, or is\n      // something's actually changed since the last render. Consecutive\n      // synchronous setState calls will queue up corresponding async render\n      // calls. By the time the first render call actually happens, the complete\n      // state is available, and that is what is rendered. When the following\n      // render calls happen, they will see that the complete state has already\n      // been rendered, and skip doing any work.\n      if (!this[mountedKey] || changed !== null) {\n\n        // If at least one of the setState calls was made in response to user\n        // interaction or some other component-internal event, set the\n        // raiseChangeEvents flag so that componentDidMount/componentDidUpdate\n        // know whether to raise property change events.\n        const saveRaiseChangeEvents = this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"raiseChangeEvents\"]];\n        this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"raiseChangeEvents\"]] = this[raiseChangeEventsInNextRenderKey];\n\n        // We set a flag to indicate that rendering is happening. The component\n        // may use this to avoid triggering other updates during the render.\n        this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"rendering\"]] = true;\n\n        // Invoke any internal render implementations.\n        this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]](changed);\n\n        this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"rendering\"]] = false;\n\n        // Since we've now rendered all changes, clear the change log. If other\n        // async render calls are queued up behind this call, they'll see an\n        // empty change log, and so skip unnecessary render work.\n        changedSinceLastRender.set(this, null);\n\n        // Let the component know it was rendered.\n        // First time is consider mounting; subsequent times are updates.\n        if (!this[mountedKey]) {\n          this.componentDidMount();\n          this[mountedKey] = true;\n        } else {\n          this.componentDidUpdate(changed);\n        }\n\n        // Restore state of event flags.\n        this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"raiseChangeEvents\"]] = saveRaiseChangeEvents;\n        this[raiseChangeEventsInNextRenderKey] = saveRaiseChangeEvents;\n      }\n    }\n\n    /**\n     * Internal method for rendering any recent changes in state to the DOM.\n     * \n     * The default implementation of this method does nothing. Override this\n     * method in your component to update your component's host element and\n     * any shadow elements to reflect the component's new state. See the\n     * [rendering example](ReactiveMixin#rendering).\n     * \n     * Be sure to call `super` in your method implementation so that your\n     * component's base classes and mixins have a chance to perform their own\n     * render work.\n     * \n     * @param {object} changed - dictionary of flags indicating which state\n     * members have changed since the last render\n     */\n    [_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]](changed) {\n      if (super[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]]) { super[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]](changed); }\n    }\n\n    /**\n     * Update the component's state by merging the specified changes on\n     * top of the existing state. If the component is connected to the document,\n     * and the new state has changed, this returns a promise to asynchronously\n     * render the component. Otherwise, this returns a resolved promise.\n     * \n     * @param {object} changes - the changes to apply to the element's state\n     * @returns {Promise} - resolves when the new state has been rendered\n     */\n    async setState(changes) {\n      // There's no good reason to have a render method update state.\n      if (this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"rendering\"]]) {\n        /* eslint-disable no-console */\n        console.warn(`${this.constructor.name} called setState during rendering, which you should avoid.\\nSee https://elix.org/documentation/ReactiveMixin.`);\n      }\n\n      const firstSetState = this[stateKey] === undefined;\n      if (firstSetState) {\n        // Create temporary state as seed.\n        this[stateKey] = Object.freeze(new _State_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]());\n      }\n\n      const { state, changed } = this[stateKey].copyWithChanges(changes);\n\n      const renderWorthy = firstSetState || changed;\n      if (!renderWorthy) {\n        // No need to update state.\n        return;\n      }\n\n      // Freeze the new state so it's immutable. This prevents accidental\n      // attempts to set state without going through setState.\n      Object.freeze(state);\n\n      // Set the new state.\n      this[stateKey] = state;\n\n      // Log the changes.\n      const log = changedSinceLastRender.get(this) || {};\n      Object.assign(log, changed);\n      changedSinceLastRender.set(this, log);\n\n      if (!(this.isConnected && renderWorthy)) {\n        // Not in document or no worthwhile changes to render.\n        return;\n      }\n\n      // Remember whether we're supposed to raise property change events.\n      if (this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"raiseChangeEvents\"]]) {\n        this[raiseChangeEventsInNextRenderKey] = true;\n      }\n      \n      // Yield with promise timing. This lets any *synchronous* setState\n      // calls that happen after the current setState call complete first.\n      // Their effects on the state will be batched up before the render\n      // call below actually happens.\n      await Promise.resolve();\n      \n      // Render the component.\n      this.render();\n    }\n\n    /**\n     * The component's current state.\n     * The returned state object is immutable. To update it, invoke `setState`.\n     * \n     * @type {State}\n     */\n    get state() {\n      return this[stateKey];\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/ReactiveMixin.js?");

/***/ }),

/***/ "./node_modules/elix/src/ShadowTemplateMixin.js":
/*!******************************************************!*\
  !*** ./node_modules/elix/src/ShadowTemplateMixin.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ShadowTemplateMixin; });\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbols.js */ \"./node_modules/elix/src/symbols.js\");\n\n\n\n// A cache of processed templates, indexed by element class.\nconst classTemplateMap = new Map();\n\n/** @type {any} */\nconst shadowReferencesKey = Symbol('shadowReferences');\n\n/**\n * Stamps a template into a component's Shadow DOM when instantiated\n *\n * To use this mixin, define a `template` method that returns a string or HTML\n * `<template>` element:\n *\n *     import * as template from 'elix/src/template.js';\n * \n *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n *       get [symbols.template]() {\n *         return template.html`Hello, <em>world</em>.`;\n *       }\n *     }\n *\n * When your component class is instantiated, a shadow root will be created on\n * the instance, and the contents of the template will be cloned into the\n * shadow root. If your component does not define a `template` method, this\n * mixin has no effect.\n * \n * This adds a member on the component called `this.$` that can be used to\n * reference shadow elements with IDs. E.g., if component's shadow contains an\n * element `<button id=\"foo\">`, then this mixin will create a member\n * `this.$.foo` that points to that button.\n *\n * @module ShadowTemplateMixin\n */\nfunction ShadowTemplateMixin(Base) {\n\n  // The class prototype added by the mixin.\n  class ShadowTemplate extends Base {\n\n    /**\n     * A convenient shortcut for looking up an element by ID in the component's\n     * Shadow DOM subtree.\n     *\n     * Example: if component's template contains a shadow element\n     * `<button id=\"foo\">`, you can use the reference `this.$.foo` to obtain\n     * the corresponding button in the component instance's shadow tree.\n     * The `$` function is simply a shorthand for `getElementById`, so\n     * `this.$.foo` is the same as `this.shadowRoot.getElementById('foo')`.\n     *\n     * @type {object} - a dictionary mapping shadow element IDs to elements\n     */\n    get $() {\n      if (!this[shadowReferencesKey]) {\n        // Construct a proxy that maps $ -> getElementById.\n        const element = this;\n        this[shadowReferencesKey] = new Proxy({}, {\n          /* eslint-disable no-unused-vars */\n          get(target, property, receiver) {\n            return element.shadowRoot ?\n              element.shadowRoot.getElementById(property) :\n              null;\n          }\n        });\n      }\n      return this[shadowReferencesKey];\n    }\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    [_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]](changed) {\n      if (super[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]]) { super[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"render\"]](changed); }\n      if (this.shadowRoot) {\n        // Already rendered\n        return;\n      }\n      \n      // If this type of element defines a template, prepare it for use.\n      const template = getTemplate(this);\n      if (template) {\n        // Stamp the template into a new shadow root.\n        const delegatesFocus = this[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"delegatesFocus\"]];\n        const root = this.attachShadow({\n          delegatesFocus,\n          mode: 'open'\n        });\n        const clone = document.importNode(template.content, true);\n        root.appendChild(clone);\n      }\n    }\n\n  }\n\n  return ShadowTemplate;\n}\n\n\nfunction getTemplate(element) {\n  const hasDynamicTemplate = element[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"hasDynamicTemplate\"]];\n  let template = hasDynamicTemplate ?\n    undefined : // Always retrieve template\n    classTemplateMap.get(element.constructor); // See if we've cached it\n  if (template === undefined) {\n    // Ask the component for its template.\n    template = element[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"template\"]] || null;\n    if (template && !(template instanceof HTMLTemplateElement)) {\n      throw `Warning: the [symbols.template] property for ${element.constructor.name} must return an HTMLTemplateElement.`;\n    }\n    if (!hasDynamicTemplate) {\n      // Store prepared template for next creation of same type of element.\n      classTemplateMap.set(element.constructor, template);\n    }\n  }\n  return template;\n}\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/ShadowTemplateMixin.js?");

/***/ }),

/***/ "./node_modules/elix/src/State.js":
/*!****************************************!*\
  !*** ./node_modules/elix/src/State.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst changeCallbacksKey = Symbol('changeCallbacks');\n\n\n/**\n * A state object that can reconcile changes from multiple sources.\n */\nclass State {\n\n  constructor(defaults) {\n    if (defaults) {\n      applyStateChanges(this, defaults);\n    }\n  }\n\n  /**\n   * Return a new copy of this state that includes the indicated changes,\n   * invoking any registered `onChange` handlers that depend on the changed\n   * state members.\n   * \n   * There is no need to invoke this method yourself.\n   * [ReactiveMixin](ReactiveMixin) will take care of doing that when you invoke\n   * [setState](ReactiveMixin#setState).\n   * \n   * @param {object} changes - the changes to apply to the state\n   * @returns {object} - the new `state`, and a `changed` flag indicating\n   * whether there were any substantive changes\n   */\n  copyWithChanges(changes) {\n    // Create a new state object that holds a copy of the old state. If we pass\n    // the current state to the State constructor, we'll trigger the application\n    // of its change handlers, which will ultimately realize the state is\n    // already as refined as possible, and so do work for nothing. So we create\n    // a new empty State, merge in the old state, then run the change handlers\n    // with the requested changes.\n    const state = Object.assign(new State(), this);\n\n    // If the changes include new change callbacks, apply those too.\n    if (changes[changeCallbacksKey]) {\n      // Also copy over the set of change callbacks.\n      state[changeCallbacksKey] = changes[changeCallbacksKey];\n    }\n\n    const changed = applyStateChanges(state, changes);\n    return { state, changed };\n  }\n  \n  /**\n   * Ask the `State` object to invoke the specified `callback` when any of the\n   * state members listed in the `dependencies` array change.\n   * \n   * The `callback` should be a function that accepts:\n   * \n   * * A `state` parameter indicating the current state.\n   * * A `changed` parameter. This will be a set of flags that indicate which\n   *   specified state members have changed since the last time the callback was\n   *   run. If the handler doesn't care about which specific members have\n   *   changed, this parameter can be omitted.\n   * \n   * The callback should return `null` if it finds the current state acceptable.\n   * If the callback wants to make changes to the state, it returns an object\n   * representing the changes that should be applied to the state. The callback\n   * does *not* need to check to see whether the changes actually need to be\n   * applied to the state; the `State` object itself will avoid applying\n   * unnecessary changes.\n   * \n   * The common place to invoke `onChange` is when an element's `defaultState`\n   * is being constructed.\n\n   * @param {string[]|string} dependencies - the name(s) of the state fields\n   * that should trigger the callback if they are changed\n   * @param {function} callback - the function to run when any of the\n   * dependencies changes\n   */\n  onChange(dependencies, callback) {\n    if (!this[changeCallbacksKey]) {\n      this[changeCallbacksKey] = {};\n    }\n    const array = dependencies instanceof Array ?\n      dependencies :\n      [dependencies];\n    // Register the callback for each dependent state field.\n    array.forEach(dependency => {\n      if (!this[changeCallbacksKey][dependency]) {\n        this[changeCallbacksKey][dependency] = []\n      }\n      this[changeCallbacksKey][dependency].push(callback);\n    });\n  }\n\n}\n\n\nfunction equal(value1, value2) {\n  if (value1 instanceof Date && value2 instanceof Date) {\n    return value1.getTime() === value2.getTime();\n  }\n  return value1 === value2;\n}\n\n\n// Return a dictionary of flags indicating which of the indicated changes to the\n// state are actually changes. Return null if there were no changes.\nfunction fieldsChanged(state, changes) {\n  let changed = null;\n  for (const field in changes) {\n    if (!equal(changes[field], state[field])) {\n      if (!changed) {\n        changed = {};\n      }\n      changed[field] = true;\n    }\n  }\n  return changed;\n}\n\n\n// Destructively apply the indicated changes to the given state, running\n// any registered change handlers.\n// Return a dictionary of flags indicating which fields actually changed,\n// or null if there were no changes.\nfunction applyStateChanges(state, changes) {\n  let result = null;\n\n  // Applying the changes may produce a new round of changes, and that round\n  // might produce new changes, and so on. Loop until we complete a pass that\n  // produces no changes.\n  for (\n    let changed;\n    changed = fieldsChanged(state, changes), changed;\n  ) {\n\n    // Apply the changes to the state.\n    Object.assign(state, changes);\n\n    // Remember what actually changed.\n    if (!result) {\n      result = {};\n    }\n    Object.assign(result, changed);\n\n    // Run the change handlers, gathering up the changes those produce.\n    changes = {};\n    if (state[changeCallbacksKey]) {\n      // Get callbacks for fields that changed.\n      const callbacks = [];\n      for (const field in changed) {\n        const callbacksForField = state[changeCallbacksKey][field] || [];\n        callbacksForField.forEach(callback => {\n          // A single callback may be triggered by multiple fields; only add a\n          // callback to the list if it's not already there.\n          // @ts-ignore\n          if (!callbacks.includes(callback)) {\n            callbacks.push(callback);\n          }\n        });\n      }\n      // Run the callbacks and collect their changes.\n      const results = callbacks.map(callback => callback(state, changed));\n      // If the change handlers produced changes, we'll run the loop again.\n      Object.assign(changes, ...results);\n    }\n  }\n\n  return result;\n}\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (State);\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/State.js?");

/***/ }),

/***/ "./node_modules/elix/src/WrappedStandardElement.js":
/*!*********************************************************!*\
  !*** ./node_modules/elix/src/WrappedStandardElement.js ***!
  \*********************************************************/
/*! exports provided: applyAttribute, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyAttribute\", function() { return applyAttribute; });\n/* harmony import */ var _AttributeMarshallingMixin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AttributeMarshallingMixin.js */ \"./node_modules/elix/src/AttributeMarshallingMixin.js\");\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbols.js */ \"./node_modules/elix/src/symbols.js\");\n/* harmony import */ var _template_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./template.js */ \"./node_modules/elix/src/template.js\");\n/* harmony import */ var _DelegateFocusMixin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DelegateFocusMixin.js */ \"./node_modules/elix/src/DelegateFocusMixin.js\");\n/* harmony import */ var _ReactiveElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ReactiveElement.js */ \"./node_modules/elix/src/ReactiveElement.js\");\n\n\n\n\n\n\n\nconst extendsKey = Symbol('extends');\n// const renderedKey = Symbol('rendered');\n\n\n/*\n * A set of events which, if fired by the inner standard element, should be\n * re-raised by the custom element.\n *\n * These are events which are spec'ed to NOT get retargetted across a Shadow DOM\n * boundary, organized by which element(s) raise the events. To properly\n * simulate these, we will need to listen for the real events, then re-raise a\n * simulation of the original event. For more information, see\n * https://www.w3.org/TR/shadow-dom/#h-events-that-are-not-leaked-into-ancestor-trees.\n *\n * It appears that we do *not* need to re-raise the non-bubbling \"focus\" and\n * \"blur\" events. These appear to be automatically re-raised as expected -- but\n * it's not clear why that happens.\n *\n * The list below is reasonably complete. It omits elements that cannot be\n * wrapped (see class notes above). Also, we haven't actually tried wrapping\n * every element in this list; some of the more obscure ones might not actually\n * work as expected, but it was easier to include them for completeness than\n * to actually verify whether or not the element can be wrapped.\n */\nconst reraiseEvents = {\n  address: ['scroll'],\n  blockquote: ['scroll'],\n  caption: ['scroll'],\n  center: ['scroll'],\n  dd: ['scroll'],\n  dir: ['scroll'],\n  div: ['scroll'],\n  dl: ['scroll'],\n  dt: ['scroll'],\n  fieldset: ['scroll'],\n  form: ['reset', 'scroll'],\n  frame: ['load'],\n  h1: ['scroll'],\n  h2: ['scroll'],\n  h3: ['scroll'],\n  h4: ['scroll'],\n  h5: ['scroll'],\n  h6: ['scroll'],\n  iframe: ['load'],\n  img: ['abort', 'error', 'load'],\n  input: ['abort', 'change', 'error', 'select', 'load'],\n  li: ['scroll'],\n  link: ['load'],\n  menu: ['scroll'],\n  object: ['error', 'scroll'],\n  ol: ['scroll'],\n  p: ['scroll'],\n  script: ['error', 'load'],\n  select: ['change', 'scroll'],\n  tbody: ['scroll'],\n  tfoot: ['scroll'],\n  thead: ['scroll'],\n  textarea: ['change', 'select', 'scroll']\n};\n\n\n/*\n * Mouse events that should be disabled if the inner component is disabled.\n */\nconst mouseEventNames = [\n  'click',\n  'dblclick',\n  'mousedown',\n  'mouseenter',\n  'mouseleave',\n  'mousemove',\n  'mouseout',\n  'mouseover',\n  'mouseup',\n  'wheel'\n];\n\n\n// Keep track of which re-raised events should bubble.\nconst eventBubbles = {\n  abort: true,\n  change: true,\n  reset: true\n};\n\n\n// Elements which are display: block by default.\n// Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\nconst blockElements = [\n  'address',\n  'article',\n  'aside',\n  'blockquote',\n  'canvas',\n  'dd',\n  'div',\n  'dl',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'header',\n  'hgroup',\n  'hr',\n  'li',\n  'main',\n  'nav',\n  'noscript',\n  'ol',\n  'output',\n  'p',\n  'pre',\n  'section',\n  'table',\n  'tfoot',\n  'ul',\n  'video'\n];\n\n\n// Standard attributes that don't have corresponding properties.\n// These need to be delegated from the wrapper to the inner element.\nconst attributesWithoutProperties = [\n  'accept-charset',\n  'autoplay',\n  'buffered',\n  'challenge',\n  'codebase',\n  'colspan',\n  'contenteditable',\n  'controls',\n  'crossorigin',\n  'datetime',\n  'dirname',\n  'for',\n  'formaction',\n  'http-equiv',\n  'icon',\n  'ismap',\n  'itemprop',\n  'keytype',\n  'language',\n  'loop',\n  'manifest',\n  'maxlength',\n  'minlength',\n  'muted',\n  'novalidate',\n  'preload',\n  'radiogroup',\n  'readonly',\n  'referrerpolicy',\n  'rowspan',\n  'scoped',\n  'usemap'\n];\n\n\nconst Base =\n  Object(_DelegateFocusMixin_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n    _ReactiveElement_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]\n  );\n\n\n/**\n * Wraps a standard HTML element so it can be extended\n * \n * The typical way to use this class is via its static `wrap` method.\n * \n * @inherits ReactiveElement\n * @mixes DelegateFocusMixin\n */\nclass WrappedStandardElement extends Base {\n\n  // Wrapped standard elements need to forward some attributes to the inner\n  // element in cases where the attribute does not have a corresponding\n  // property. These attributes include those prefixed with \"aria-\", and some\n  // unusual standard attributes like contenteditable. To handle those, this\n  // class defines its own attributeChangedCallback.\n  attributeChangedCallback(name, oldValue, newValue) {\n    const forwardAttribute = attributesWithoutProperties.indexOf(name) >= 0;\n    if (forwardAttribute) {\n      const innerAttributes = Object.assign({}, this.state.innerAttributes, {\n        [name]: newValue\n      });\n      this.setState({\n        innerAttributes\n      });\n    } else {\n      // Rely on the base attributeChangedCallback provided by\n      // AttributeMarshallingMixin.\n      super.attributeChangedCallback(name, oldValue, newValue);\n    }\n  }\n\n  // Delegate method defined by HTMLElement.\n  blur() {\n    this.inner.blur();\n  }\n\n  // One HTMLElement we *don't* delegate is `click`. Generally speaking, a click\n  // on the outer wrapper should behave the same as a click on the inner\n  // element. Also, we want to ensure outside event listeners get a click event\n  // when the click method is invoked. But a click on the inner element will\n  // raise a click event that won't be re-raised by default across the shadow\n  // boundary. The precise behavior seems to be slightly different in Safari\n  // than other browsers, but it seems safer to not delegate click.\n  //\n  // click() {}\n\n  componentDidMount() {\n    super.componentDidMount();\n\n    // Listen for any events raised by the inner element which will not\n    // automatically be retargetted across the Shadow DOM boundary, and re-raise\n    // those events when they happen.\n    const eventNames = reraiseEvents[this.extends] || [];\n    eventNames.forEach(eventName => {\n      this.inner.addEventListener(eventName, () => {\n        const event = new Event(eventName, {\n          bubbles: eventBubbles[eventName] || false\n        });\n        this.dispatchEvent(event);\n      });\n    });\n\n    // If inner element can be disabled, then listen to mouse events on the\n    // *outer* element and absorb them if the inner element is disabled.\n    // Without this, a mouse event like a click on the inner disabled element\n    // would be treated as a click on the outer element. Someone listening to\n    // clicks on the outer element would get a click event, even though the\n    // overall element is supposed to be disabled.\n    if ('disabled' in this.$.inner) {\n      mouseEventNames.forEach(eventName => {\n        this.addEventListener(eventName, event => {\n          /** @type {any} */\n          const element = this.$.inner;\n          if (element.disabled) {\n            event.stopImmediatePropagation();\n          }\n        });\n      });\n    }\n\n  }\n\n  get defaultState() {\n    return Object.assign(super.defaultState, {\n      innerAttributes: {},\n      innerProperties: {}\n    });\n  }\n\n  get [_symbols_js__WEBPACK_IMPORTED_MODULE_1__[\"defaultTabIndex\"]]() {\n    const focusableByDefault = {\n      a: true,\n      area: true,\n      button: true,\n      details: true,\n      iframe: true,\n      input: true,\n      select: true,\n      textarea: true\n    };\n    return focusableByDefault[this.extends] ?\n      0 :\n      -1;\n  }\n\n  get extends() {\n    return this.constructor[extendsKey];\n  }\n  \n  /**\n   * Returns a reference to the inner standard HTML element.\n   *\n   * @type {HTMLElement}\n   */\n  get inner() {\n    /** @type {any} */\n    const result = this.$ && this.$.inner;\n    if (!result) {\n      /* eslint-disable no-console */\n      console.warn('Attempted to get an inner standard element before it was instantiated.');\n    }\n    return result;\n  }\n  \n  getInnerProperty(name) {\n    // If we haven't rendered yet, use internal state value. Once we've\n    // rendered, we get the value from the wrapped element itself. Return our\n    // concept of the current property value from state. If the property hasn't\n    // been defined, however, get the current value of the property from the\n    // inner element.\n    //\n    // This is intended to support cases like an anchor element. If someone sets\n    // `href` on a wrapped anchor, we'll know the value of `href` from state,\n    // but we won't know the value of href-dependent calculated properties like\n    // `protocol`. Using two sources of truth (state and the inner element)\n    // seems fragile, but it's unclear how else to handle this without\n    // reimplementing all HTML property interactions ourselves.\n    //\n    // This arrangement also means that, if an inner element property can change\n    // in response to user interaction (e.g., an input element's value changes\n    // as the user types), the component must listen to suitable events on the\n    // inner element and update its state accordingly.\n    const value = this.state.innerProperties[name];\n    return value || (this.shadowRoot && this.inner[name]);\n  }\n\n  static get observedAttributes() {\n    // For our custom attributeChangedCallback to work, we need to observe\n    // the attributes we want to forward.\n    // @ts-ignore\n    return [...super.observedAttributes, ...attributesWithoutProperties];\n  }\n\n  [_symbols_js__WEBPACK_IMPORTED_MODULE_1__[\"render\"]](changed) {\n    super[_symbols_js__WEBPACK_IMPORTED_MODULE_1__[\"render\"]](changed);\n    const inner = this.inner;\n    if (changed.tabIndex) {\n      inner.tabIndex = this.state.tabIndex;\n    }\n    if (changed.innerAttributes) {\n      // Forward attributes to the inner element.\n      // See notes at attributeChangedCallback.\n      const { innerAttributes } = this.state;\n      for (const name in innerAttributes) {\n        applyAttribute(inner, name, innerAttributes[name]);\n      }\n    }\n    if (changed.innerProperties) {\n      const { innerProperties } = this.state;\n      Object.assign(inner, innerProperties);\n      const { disabled } = innerProperties;\n      if (disabled !== undefined) {\n        this.toggleAttribute('disabled', disabled);\n      }\n    }\n  }\n\n  // Save property assignment in state.\n  setInnerProperty(name, value) {\n    // We normally don't check an existing state value before calling setState,\n    // relying instead on setState to do that check for us. However, we have\n    // dangers in this particular component of creating infinite loops.\n    //\n    // E.g., setting the tabindex attibute will call attributeChangedCallback,\n    // which will set the tabIndex property, which will want to set state, which\n    // will cause a render, which will try to reflect the current value of the\n    // tabIndex property to the tabindex attribute, causing a loop.\n    //\n    // To avoid this, we check the existing value before updating our state.\n    const current = this.state.innerProperties[name];\n    if (current !== value) {\n      const innerProperties = Object.assign({}, this.state.innerProperties, {\n        [name]: value\n      });\n      this.setState({ innerProperties });\n    }\n  }\n\n  /**\n   * The template copied into the shadow tree of new instances of this element.\n   *\n   * The default value of this property is a template that includes an instance\n   * the standard element being wrapped, with a `<slot>` element inside that\n   * to pick up the element's light DOM content. For example, if you wrap an\n   * `<a>` element, then the default template will look like:\n   *\n   *     <template>\n   *       <style>\n   *       :host {\n   *         display: inline-block;\n   *       }\n   *       </style>\n   *       <a id=\"inner\">\n   *         <slot></slot>\n   *       </a>\n   *     </template>\n   *\n   * The `display` styling applied to the host will be `block` for elements that\n   * are block elements by default, and `inline-block` (not `inline`) for other\n   * elements.\n   *\n   * If you'd like the template to include other elements, then override this\n   * property and return a template of your own. The template should include an\n   * instance of the standard HTML element you are wrapping, and the ID of that\n   * element should be \"inner\".\n   *\n   * @type {(string|HTMLTemplateElement)}\n   */\n  get [_symbols_js__WEBPACK_IMPORTED_MODULE_1__[\"template\"]]() {\n    const display = blockElements.indexOf(this.extends) >= 0 ?\n      'block' :\n      'inline-block';\n    return _template_js__WEBPACK_IMPORTED_MODULE_2__[\"html\"]`<style>:host { display: ${display}} #inner { box-sizing: border-box; height: 100%; width: 100%; }</style><${this.extends} id=\"inner\"><slot></slot></${this.extends}`;\n  }\n\n  /**\n   * Creates a class that wraps a standard HTML element.\n   *\n   * Note that the resulting class is a subclass of WrappedStandardElement, not\n   * the standard class being wrapped. E.g., if you call\n   * `WrappedStandardElement.wrap('a')`, you will get a class whose shadow tree\n   * will include an anchor element, but the class will *not* inherit from\n   * HTMLAnchorElement.\n   *\n   * @static\n   * @param {string} extendsTag - the standard HTML element tag to extend\n   */\n  static wrap(extendsTag) {\n\n    // Create the new class.\n    class Wrapped extends WrappedStandardElement {}\n    \n    // Indicate which tag it wraps.\n    Wrapped[extendsKey] = extendsTag;\n\n    // Create getter/setters that delegate to the wrapped element.\n    const element = document.createElement(extendsTag);\n    defineDelegates(Wrapped, Object.getPrototypeOf(element));\n\n    return Wrapped;\n  }\n\n}\n\n\n// Update the given attribute on an element.\n// \n// Passing a non-null `value` acts like a call to `setAttribute(name, value)`.\n// If the supplied `value` is nullish, this acts like a call to\n// `removeAttribute(name)`.\n//\nfunction applyAttribute(element, name, value) {\n  if (_AttributeMarshallingMixin_js__WEBPACK_IMPORTED_MODULE_0__[\"booleanAttributes\"][name]) {\n    // Boolean attribute\n    if (typeof value === 'string') {\n      element.setAttribute(name, '');\n    } else if (value === null) {\n      element.removeAttribute(name);\n    }\n  } else {\n    // Regular string-valued attribute\n    if (value != null) {\n      element.setAttribute(name, value.toString());\n    } else {\n      element.removeAttribute(name);\n    }\n  }\n}\n\n\nfunction createDelegate(name, descriptor) {\n  if (typeof descriptor.value === 'function') {\n    if (name !== 'constructor') {\n      return createMethodDelegate(name, descriptor);\n    }\n  } else if (typeof descriptor.get === 'function' ||\n    typeof descriptor.set === 'function') {\n    return createPropertyDelegate(name, descriptor);\n  }\n  return null;\n}\n\n\nfunction createMethodDelegate(name, descriptor) {\n  const value = function(...args) {\n    // @ts-ignore\n    this.inner[name](...args);\n  };\n  const delegate = {\n    configurable: descriptor.configurable,\n    enumerable: descriptor.enumerable,\n    value,\n    writable: descriptor.writable\n  };\n  return delegate;\n}\n\n\nfunction createPropertyDelegate(name, descriptor) {\n  const delegate = {\n    configurable: descriptor.configurable,\n    enumerable: descriptor.enumerable\n  };\n  if (descriptor.get) {\n    delegate.get = function() {\n      return this.getInnerProperty(name);\n    };\n  }\n  if (descriptor.set) {\n    delegate.set = function(value) {\n      this.setInnerProperty(name, value);\n    };\n  }\n  if (descriptor.writable) {\n    delegate.writable = descriptor.writable;\n  }\n  return delegate;\n}\n\n\n// Define delegates for the given class for each property/method on the\n// indicated prototype.\nfunction defineDelegates(cls, prototype) {\n  const names = Object.getOwnPropertyNames(prototype);\n  names.forEach(name => {\n    const descriptor = Object.getOwnPropertyDescriptor(prototype, name);\n    if (!descriptor) {\n      return;\n    }\n    const delegate = createDelegate(name, descriptor);\n    if (delegate) {\n      Object.defineProperty(cls.prototype, name, delegate);\n    }\n  });\n}\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (WrappedStandardElement);\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/WrappedStandardElement.js?");

/***/ }),

/***/ "./node_modules/elix/src/symbols.js":
/*!******************************************!*\
  !*** ./node_modules/elix/src/symbols.js ***!
  \******************************************/
/*! exports provided: checkSize, contentSlot, defaultTabIndex, delegatesFocus, elementsWithTransitions, focusTarget, getItemText, goDown, goEnd, goLeft, goRight, goStart, goUp, hasDynamicTemplate, itemMatchesState, itemsDelegate, keydown, mouseenter, mouseleave, populate, raiseChangeEvents, render, rendering, scrollTarget, startEffect, swipeDown, swipeLeft, swipeRight, swipeUp, swipeTarget, tap, template, update */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkSize\", function() { return checkSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"contentSlot\", function() { return contentSlot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultTabIndex\", function() { return defaultTabIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"delegatesFocus\", function() { return delegatesFocus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"elementsWithTransitions\", function() { return elementsWithTransitions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"focusTarget\", function() { return focusTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getItemText\", function() { return getItemText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"goDown\", function() { return goDown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"goEnd\", function() { return goEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"goLeft\", function() { return goLeft; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"goRight\", function() { return goRight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"goStart\", function() { return goStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"goUp\", function() { return goUp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasDynamicTemplate\", function() { return hasDynamicTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"itemMatchesState\", function() { return itemMatchesState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"itemsDelegate\", function() { return itemsDelegate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keydown\", function() { return keydown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mouseenter\", function() { return mouseenter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mouseleave\", function() { return mouseleave; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"populate\", function() { return populate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"raiseChangeEvents\", function() { return raiseChangeEvents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rendering\", function() { return rendering; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scrollTarget\", function() { return scrollTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startEffect\", function() { return startEffect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"swipeDown\", function() { return swipeDown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"swipeLeft\", function() { return swipeLeft; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"swipeRight\", function() { return swipeRight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"swipeUp\", function() { return swipeUp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"swipeTarget\", function() { return swipeTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tap\", function() { return tap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"template\", function() { return template; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"update\", function() { return update; });\n/**\n * Collection of shared Symbol objects for internal component communication.\n * \n * The shared `Symbol` objects in this module let mixins and a component\n * internally communicate without exposing these properties and methods in the\n * component's public API. They also help avoid unintentional name collisions,\n * as a component developer must specifically import the `symbols` module and\n * reference one of its symbols.\n *\n * To use these `Symbol` objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol. E.g.,\n * [ShadowTemplateMixin](ShadowTemplateMixin) expects a component to define\n * a property called [symbols.template](#template):\n *\n *     import * as template from 'elix/src/template.js'\n *     import * as symbols from 'elix/src/symbols.js';\n *     import ShadowTemplateMixin from 'elix/src/ShadowTemplateMixin.js';\n * \n *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n *       [symbols.template]() {\n *         return template.html`Hello, <em>world</em>.`;\n *       }\n *     }\n * \n * The above use of `symbols.template` lets the mixin find the component's\n * template in a way that will not pollute the component's public API or\n * interfere with other component logic. For example, if for some reason the\n * component wants to define a separate property with the plain string name,\n * \"template\", it can do so without affecting the above property setter.\n * \n * While this project generally uses `Symbol` objects to hide component\n * internals, Elix does make some exceptions for methods or properties that are\n * very helpful to have handy during debugging. E.g.,\n * [ReactiveMixin](ReactiveMixin) exposes its [setState](ReactiveMixin#setState)\n * method publicly, even though invoking that method from outside a component is\n * generally bad practice. The mixin exposes `setState` because it's very useful\n * to have access to that in a debug console.\n *\n * @module symbols\n */\n\n/**\n * Symbol for the `checkSize` method.\n * \n * If defined, this method will be invoked by [ResizeMixin](ResizeMixin)\n * when an element's size may have changed. The default implementation of\n * this method compares the element's current `clientHeight` and `clientWidth`\n * properties against the last known values of those properties (saved in\n * `state.clienHeight` and `state.clientWidth`).\n * \n * Components should override this method if they contain elements that may need\n * to know about size changes as well. For example, when an [Overlay](Overlay)\n * mixin opens, it invokes this method on any content elements that define it.\n * This gives the contents a chance to resize in response to being displayed.\n */\nconst checkSize = Symbol('checkSize');\n\n/**\n * Symbol for the `contentSlot` property.\n * \n * [SlotContentMixin](SlotContentMixin) uses this to identify which slot\n * element in the component's shadow tree that holds the component's content.\n * By default, this is the first slot element with no \"name\" attribute. You\n * can override this to return a different slot.\n * \n * @var {HTMLSlotElement} contentSlot\n */\nconst contentSlot = Symbol('contentSlot');\n\n/**\n * Symbol for the `defaultTabIndex` property.\n * \n * [KeyboardMixin](KeyboardMixin) uses this if it is unable to successfully\n * parse a string tabindex attribute.\n */\nconst defaultTabIndex = Symbol('defaultTabIndex');\n\n/**\n * Symbol for the `delegatesFocus` property.\n * \n * [DelegatesFocusMixin](DelegatesFocusMixin) defines this property, returning\n * true to indicate that the focus is being delegated, even in browsers that\n * don't support that natively. Mixins like [KeyboardMixin](KeyboardMixin) use\n * this to accommodate focus delegation.\n */\nconst delegatesFocus = Symbol('delegatesFocus');\n\n/**\n * Symbol for the `elementsWithTransitions` property.\n * \n * [TransitionEffectMixin](TransitionEffectMixin) inspects this property\n * to determine which element(s) have CSS\n * transitions applied to them for visual effects.\n * \n * @returns {Element[]} The elements with CSS transitions\n */\nconst elementsWithTransitions = Symbol('elementsWithTransitions');\n\n/**\n * Symbol for the `focusTarget` property.\n * \n * [DelegatesFocusMixin](DelegatesFocusMixin) defines this property as either:\n * 1) the element itself, in browsers that support native focus delegation or,\n * 2) the shadow root's first focusable element.\n */\nconst focusTarget = Symbol('focusTarget');\n\n/**\n * Symbol for the `getItemText` method.\n *\n * This method can be applied to an item to return its text.\n * [KeyboardPrefixSelectionMixin](KeyboardPrefixSelectionMixin) uses this to\n * obtain the text for each item in a list, then matches keypresses again that\n * text.\n * \n * This method takes a single parameter: the `HTMLElement` of the item from\n * which text should be extracted.\n *\n * @function getItemText\n * @returns {string} the text of the item\n */\nconst getItemText = Symbol('getItemText');\n\n/**\n * Symbol for the `goDown` method.\n *\n * This method is invoked when the user wants to go/navigate down.\n *\n * @function goDown\n */\nconst goDown = Symbol('goDown');\n\n/**\n * Symbol for the `goEnd` method.\n *\n * This method is invoked when the user wants to go/navigate to the end (e.g.,\n * of a list).\n *\n * @function goEnd\n */\nconst goEnd = Symbol('goEnd');\n\n/**\n * Symbol for the `goLeft` method.\n *\n * This method is invoked when the user wants to go/navigate left. Mixins that\n * make use of this method include\n * [KeyboardDirectionMixin](KeyboardDirectionMixin) and\n * [SwipeDirectionMixin](SwipeDirectionMixin).\n *\n * @function goLeft\n */\nconst goLeft = Symbol('goLeft');\n\n/**\n * Symbol for the `goRight` method.\n *\n * This method is invoked when the user wants to go/navigate right. Mixins\n * that make use of this method include\n * [KeyboardDirectionMixin](KeyboardDirectionMixin) and\n * [SwipeDirectionMixin](SwipeDirectionMixin).\n *\n * @function goRight\n */\nconst goRight = Symbol('goRight');\n\n/**\n * Symbol for the `goStart` method.\n *\n * This method is invoked when the user wants to go/navigate to the start\n * (e.g., of a list).\n *\n * @function goStart\n */\nconst goStart = Symbol('goStart');\n\n/**\n * Symbol for the `goUp` method.\n *\n * This method is invoked when the user wants to go/navigate up.\n *\n * @function goUp\n */\nconst goUp = Symbol('goUp');\n\n/**\n * Symbol for the `hasDynamicTemplate` property.\n * \n * If your component class does not always use the same template, define a\n * static class property getter with this symbol and have it return `true`.\n * This will disable template caching for your component.\n */\nconst hasDynamicTemplate = Symbol('hasDynamicTemplate');\n\n/**\n * Symbol for the `itemMatchesState` method.\n * \n * `ContentItemsMixin` uses this callback to determine whether a content node\n * should be included in the `items` collection in the given state. By default,\n * substantive, visible elements are considered items; other nodes (including\n * text nodes, comment nodes, processing instructions) and invisible elements\n * (including `script` and `style` tags) are not considered to be items.\n * \n * Various mixins and components override this to refine the idea of what\n * counts as an item. E.g., [Menu](Menu) overrides this to exclude disabled\n * menu items, using code similar to this:\n * \n *     // Filter the set of items to ignore disabled items.\n *     [symbols.itemMatchesState](item, state) {\n *       const base = super[symbols.itemMatchesState] ?\n *         super[symbols.itemMatchesState](item, state) :\n *         true;\n *       return base && !item.disabled;\n *     }\n *\n * @function itemMatchesState\n * @param {Node} item - the node that may or may not belong in the given state\n * @param {object} state - the state in question\n * @returns {boolean}\n */\nconst itemMatchesState = Symbol('itemMatchesState');\n\n/**\n * Symbol for the `itemsDelegate` property.\n * \n * A component using [DelegateItemsMixin](DelegateItemsMixin) uses this property\n * to indicate which one of its shadow elements is the one whose `items`\n * property will be treated as the component's own `items`.\n * \n * @var {Element} itemsDelegate\n */\nconst itemsDelegate = Symbol('itemsDelegate');\n\n/**\n * Symbol for the `keydown` method.\n *\n * This method is invoked when an element receives a `keydown` event.\n *\n * An implementation of `symbols.keydown` should return `true` if it handled\n * the event, and `false` otherwise. If `true` is returned (the event was\n * handled), `KeyboardMixin` invokes the event's `preventDefault` and\n * `stopPropagation` methods to let the browser know the event was handled.\n * \n * The convention for handling `symbols.keydown` is that the last mixin\n * applied wins. That is, if an implementation of `symbols.keydown` *did*\n * handle the event, it can return immediately. If it did not, it should\n * invoke `super` to let implementations further up the prototype chain have\n * their chance.\n * \n * This method takes a `KeyboardEvent` parameter that contains the event being\n * processed.\n *\n * @function keydown\n */\nconst keydown = Symbol('keydown');\n\n/**\n * Symbol for the `mouseenter` method.\n * \n * [HoverMixin](HoverMixin) invokes this method when the user moves the\n * mouse over a component. That mixin provides a base implementation of this\n * method, but you can extend it to do additional work on `mouseenter`.\n * \n * This method takes a `MouseEvent` parameter that contains the event being\n * processed.\n *\n * @function mouseenter\n */\nconst mouseenter = Symbol('mouseenter');\n\n/**\n * Symbol for the `mouseleave` method.\n * \n * [HoverMixin](HoverMixin) invokes this method when the user moves off a\n * component. That mixin provides a base implementation of this method, but\n * you can extend it to do additional work on `mouseleave`.\n * \n * This method takes a `MouseEvent` parameter that contains the event being\n * processed.\n *\n * @function mouseleave\n */\nconst mouseleave = Symbol('mouseleave');\n\n/**\n * Symbol for the `populate` method.\n * \n * [PopulateUpdateMixin](PopulateUpdateMixin) invokes this method as the first\n * of two rendering phases. In this phase, the component can manipulate the\n * Shadow DOM tree to ensure the correct elements are present.\n * \n * @function populate\n */\nconst populate = Symbol('populate');\n\n/**\n * Symbol for the `raiseChangeEvents` property.\n *\n * This property is used by mixins to determine whether they should raise\n * property change events. The standard HTML pattern is to only raise such\n * events in response to direct user interactions. For a detailed discussion\n * of this point, see the Gold Standard checklist item for\n * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n *\n * The above article describes a pattern for using a flag to track whether\n * work is being performed in response to internal component activity, and\n * whether the component should therefore raise property change events.\n * This `raiseChangeEvents` symbol is a shared flag used for that purpose by\n * all Elix mixins and components. Sharing this flag ensures that internal\n * activity (e.g., a UI event listener) in one mixin can signal other mixins\n * handling affected properties to raise change events.\n *\n * All UI event listeners (and other forms of internal handlers, such as\n * timeouts and async network handlers) should set `raiseChangeEvents` to\n * `true` at the start of the event handler, then `false` at the end:\n *\n *     this.addEventListener('click', event => {\n *       this[symbols.raiseChangeEvents] = true;\n *       // Do work here, possibly setting properties, like:\n *       this.foo = 'Hello';\n *       this[symbols.raiseChangeEvents] = false;\n *     });\n *\n * Elsewhere, property setters that raise change events should only do so it\n * this property is `true`:\n *\n *     set foo(value) {\n *       // Save foo value here, do any other work.\n *       if (this[symbols.raiseChangeEvents]) {\n *         export const event = new CustomEvent('foo-changed');\n *         this.dispatchEvent(event);\n *       }\n *     }\n *\n * In this way, programmatic attempts to set the `foo` property will not\n * trigger the `foo-changed` event, but UI interactions that update that\n * property will cause those events to be raised.\n *\n * @var {boolean} raiseChangeEvents\n */\nconst raiseChangeEvents = Symbol('raiseChangeEvents');\n\n/**\n * Symbol for an internal `render` method.\n * \n * [ReactiveMixin](ReactiveMixin) has a public [render](ReactiveMixin#render)\n * method that can be invoked to force the component to render. That public\n * method internally invokes an `symbols.render` method, which a component can\n * implement to actually render itself.\n * \n * @function render\n */\nconst render = Symbol('render');\n\n/**\n * Symbol for the `rendering` property.\n * \n * [ReactiveMixin](ReactiveMixin) sets this property to true during rendering,\n * at other times it will be false.\n * \n * @var {boolean} rendering\n */\nconst rendering = Symbol('rendering');\n\n/**\n * Symbol for the `scrollTarget` property.\n *\n * This property indicates which element in a component's shadow subtree\n * should be scrolled. [SelectionInViewMixin](SelectionInViewMixin) can use\n * this property to determine which element should be scrolled to keep the\n * selected item in view.\n * \n * @var {Element} scrollTarget\n */\nconst scrollTarget = Symbol('scrollTarget');\n\n/**\n * Symbol for the `startEffect` method.\n * \n * A component using [TransitionEffectMixin](TransitionEffectMixin) can invoke\n * this method to trigger the application of a named, asynchronous CSS\n * transition effect.\n * \n * This method takes a single `string` parameter giving the name of the effect\n * to start.\n * \n * @function startEffect\n */\nconst startEffect = Symbol('startEffect');\n\n/**\n * Symbol for the `swipeDown` method.\n * \n * The swipe mixin [TouchSwipeMixin](TouchSwipeMixin) invokes this method when\n * the user finishes a gesture to swipe down.\n * \n * @function swipeDown\n */\nconst swipeDown = Symbol('swipeDown');\n\n/**\n * Symbol for the `swipeLeft` method.\n * \n * The swipe mixins [TouchSwipeMixin](TouchSwipeMixin) and\n * [TrackpadSwipeMixin](TrackpadSwipeMixin) invoke this method when the user\n * finishes a gesture to swipe left.\n * \n * @function swipeLeft\n */\nconst swipeLeft = Symbol('swipeLeft');\n\n/**\n * Symbol for the `swipeLeft` method.\n * \n * The swipe mixins [TouchSwipeMixin](TouchSwipeMixin) and\n * [TrackpadSwipeMixin](TrackpadSwipeMixin) invoke this method when the user\n * finishes a gesture to swipe left.\n * \n * @function swipeRight\n */\nconst swipeRight = Symbol('swipeRight');\n\n/**\n * Symbol for the `swipeUp` method.\n * \n * The swipe mixin [TouchSwipeMixin](TouchSwipeMixin) invokes this method when\n * the user finishes a gesture to swipe up.\n * \n * @function swipeUp\n */\nconst swipeUp = Symbol('swipeUp');\n\n/**\n * Symbol for the `swipeTarget` property.\n * \n * By default, the swipe mixins [TouchSwipeMixin](TouchSwipeMixin) and\n * [TrackpadSwipeMixin](TrackpadSwipeMixin) assume that the element the user\n * is swiping the top-level element. In some cases (e.g., [Drawer](Drawer)),\n * the component wants to let the user swipe a shadow element. In such cases,\n * this property should return the element that should be swiped.\n * \n * The swipe target's `offsetWidth` is used by the mixin to calculate the\n * `state.swipeFraction` member when the user drags their finger. The\n * `swipeFraction` is the distance the user has dragged in the current drag\n * operation over that `offsetWidth`.\n * \n * @var {HTMLElement} swipeTarget\n */\nconst swipeTarget = Symbol('swipeTarget');\n\n/**\n * Symbol for the `tap` method.\n *\n * This method is invoked when an element receives an operation that should\n * be interpreted as a tap. [TapSelectionMixin](TapSelectionMixin)\n * invokes this when the element receives a `mousedown` event, for example.\n *\n * @function tap\n */\nconst tap = Symbol('tap');\n\n/**\n * Symbol for the `template` method.\n *\n * [ShadowTemplateMixin](ShadowTemplateMixin) uses this property to obtain a\n * component's template, which it will clone into a component's shadow root.\n * \n * @var {HTMLTemplateElement} template\n */\nconst template = Symbol('template');\n\n/**\n * Symbol for the `update` method.\n * \n * [PopulateUpdateMixin](PopulateUpdateMixin) invokes this method as the second\n * of two rendering phases. In this phase, the component can apply updates to\n * the top-level host element or its shadow elements to reflect the component's\n * current state.\n * \n * @function update\n */\nconst update = Symbol('update');\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/symbols.js?");

/***/ }),

/***/ "./node_modules/elix/src/template.js":
/*!*******************************************!*\
  !*** ./node_modules/elix/src/template.js ***!
  \*******************************************/
/*! exports provided: concat, createElement, defaultSlot, html, replace, transmute, wrap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"concat\", function() { return concat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createElement\", function() { return createElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultSlot\", function() { return defaultSlot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"html\", function() { return html; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"replace\", function() { return replace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transmute\", function() { return transmute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wrap\", function() { return wrap; });\n/**\n * Helpers for dynamically creating and patching component templates.\n * \n * The [ShadowTemplateMixin](ShadowTemplateMixin) lets you define a component\n * template that will be used to popuplate the shadow subtree of new component\n * instances. These helpers, especially the [html](#html) function, are intended\n * to simplify the creation of such templates.\n * \n * In particular, these helpers can be useful in [patching\n * templates](customizing#template-patching) inherited from a base class.\n * \n * Some of these functions take _descriptors_ that can either be a class, a tag\n * name, or an HTML template. These are generally used to fill specific roles in\n * an element's template; see [element roles](customizing#element-roles).\n * \n * @module template\n */\n\n\n/**\n * Returns a new template whose content is the concatenated content of the\n * supplied templates.\n * \n * This function is used by Elix components to customize their appearance,\n * For example, a component might\n * [append an additional stylesheet](customizing#appending-an-additional-stylesheet)\n * to extend or override the styles provided by a base class template.\n * \n * @param  {HTMLTemplateElement[]} templates - the templates to concatenate\n * @returns {HTMLTemplateElement} - a new template created by concatenating the\n * input templates\n */\nfunction concat(...templates) {\n  const result = document.createElement('template');\n  templates.forEach(template => {\n    const clone = document.importNode(template.content, true);\n    result.content.appendChild(clone);\n  });\n  return result;\n}\n\n\n/**\n * Create an element from a role descriptor (a component class constructor,\n * an HTML tag name, or an HTML template).\n * \n * If the descriptor is an HTML template, and the resulting document fragment\n * contains a single top-level node, that node is returned directly (instead of\n * the fragment).\n * \n * @param {(Function|string|HTMLTemplateElement)} descriptor - the descriptor that\n * will be used to create the element\n * @returns {Node} the new element\n */\nfunction createElement(descriptor) {\n  if (typeof descriptor === 'function') {\n    // Component class constructor\n    /** @type {any} */\n    const cast = descriptor;\n    return new cast();\n  } else if (descriptor instanceof HTMLTemplateElement) {\n    // Template\n    const fragment = document.importNode(descriptor.content, true);\n    return fragment.children.length === 1 ?\n      fragment.children[0] :\n      fragment;\n  } else {\n    // String tag name: e.g., 'div'\n    return document.createElement(descriptor);\n  }\n}\n\n\n/**\n * Search a tree for a default slot: a slot with no \"name\" attribute. Return\n * null if not found.\n * \n * @param {DocumentFragment} tree - the tree to search\n * @returns {Node|null}\n */\nfunction defaultSlot(tree) {\n  return tree.querySelector('slot:not([name])');\n}\n\n\n/**\n * A JavaScript template string literal that returns an HTML template.\n * \n * Example:\n * \n *     const myTemplate = html`Hello, <em>world</em>.`\n * \n * returns an `HTMLTemplateElement` whose `innerHTML` is `Hello, <em>world</em>.`\n * \n * This function is called `html` so that it can be easily used with HTML\n * syntax-highlighting extensions for various popular code editors.\n * \n * @param {TemplateStringsArray} strings - the strings passed to the JavaScript template\n * literal\n * @param {string[]} substitutions - the variable values passed to the\n * JavaScript template literal\n * @returns {HTMLTemplateElement}\n */\nfunction html(strings, ...substitutions) {\n  // Concatenate the strings and substitutions.\n  const complete = strings.map((string, index) => {\n    const substitution = index < substitutions.length ?\n      substitutions[index] :\n      '';\n    return `${string}${substitution}`;\n  }).join('');\n  const template = document.createElement('template');\n  template.innerHTML = complete;\n  return template;\n}\n\n\n/**\n * Replace an original node in a tree or document fragment with the indicated\n * replacement node. The attributes, classes, styles, and child nodes of the\n * original node will be moved to the replacement.\n * \n * @param {(Node|null)} original - an existing node to be replaced\n * @param {Node} replacement - the node to replace the existing node with\n * @returns {Node} the updated replacement node\n */\nfunction replace(original, replacement) {\n  if (!original) {\n    throw 'The original element could not be found.';\n  }\n  const parent = original.parentNode;\n  if (!parent) {\n    throw 'An element must have a parent before it can be substituted.'\n  }\n  if ((original instanceof HTMLElement || original instanceof SVGElement) &&\n      (replacement instanceof HTMLElement || replacement instanceof SVGElement)) {\n    // Merge attributes from original to replacement, letting replacement win\n    // conflicts. Handle classes and styles separately (below).\n    Array.prototype.forEach.call(original.attributes, attribute => {\n      if (!replacement.getAttribute(attribute.name) &&\n          attribute.name !== 'class' && attribute.name !== 'style') {\n        replacement.setAttribute(attribute.name, attribute.value);\n      }\n    });\n    // Copy classes/styles from original to replacement, letting replacement win\n    // conflicts.\n    Array.prototype.forEach.call(original.classList, className => {\n      replacement.classList.add(className);\n    });\n    Array.prototype.forEach.call(original.style, key => {\n      if (!replacement.style[key]) {\n        replacement.style[key] = original.style[key];\n      }\n    });\n  }\n  // Copy over children.\n  while(original.childNodes.length > 0) {\n    replacement.appendChild(original.childNodes[0]);\n  }\n\n  parent.replaceChild(replacement, original);\n  return replacement;\n}\n\n\n/**\n * Replace a node or nodes with new element(s), transferring all attributes,\n * classes, styles, and child nodes from the original(s) to the replacement(s).\n * \n * The descriptor used for the replacements can be a 1) component class\n * constructor, 2) an HTML tag name, or 3) an HTML template. For #1 and #2, if\n * the existing elements that match the selector are already of the desired\n * class/tag name, the replacement operation is skipped.\n * \n * @param {(Array|NodeList|Node)} original - the node to replace\n * @param {(Function|string|HTMLTemplateElement)} descriptor - the descriptor used\n * to generate replacement elements\n * @returns {Array|Node} the replacement node(s)\n */\nfunction transmute(original, descriptor) {\n  if (original instanceof Array) {\n    // Transmute an array.\n    const replacements = original.map(node => transmute(node, descriptor));\n    return replacements;\n  } else if (original instanceof NodeList) {\n    // Transmute a list of nodes.\n    const replacements = [...original].map(node => transmute(node, descriptor));\n    return replacements;\n  } else if ((typeof descriptor === 'function' && original.constructor === descriptor) ||\n    (typeof descriptor === 'string' && original instanceof Element && \n      original.localName === descriptor)) {\n    // Already correct type of element, no transmutation necessary.\n    return original;\n  } else {\n    // Transmute the single node.\n    const replacement = createElement(descriptor);\n    replace(original, replacement);\n    return replacement;\n  }\n}\n\n\n/**\n * Destructively wrap a node or document fragment with the indicated wrapper\n * node. The contents of the original node/fragment are moved to the indicated\n * destination node (which should be a node within the wrapper).\n * \n * @param {Node} original - the node to wrap\n * @param {(DocumentFragment|Element)} wrapper - the node to wrap with\n * @param {string} destination - a CSS selector indicated a node in the wrapper\n * in which the original node should be put\n */\nfunction wrap(original, wrapper, destination) {\n  const destinationNode = wrapper.querySelector(destination);\n  if (!destinationNode) {\n    throw `Can't find the wrapper destination indicated by \"${destination}\".`;\n  }\n  if (original.parentNode) {\n    original.parentNode.replaceChild(wrapper, original);\n    destinationNode.appendChild(original);\n  } else if (original instanceof DocumentFragment) {\n    while (original.childNodes.length > 0) {\n      destinationNode.appendChild(original.childNodes[0]);\n    }\n    original.appendChild(wrapper);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/template.js?");

/***/ }),

/***/ "./node_modules/elix/src/utilities.js":
/*!********************************************!*\
  !*** ./node_modules/elix/src/utilities.js ***!
  \********************************************/
/*! exports provided: applyChildNodes, closestFocusableAncestor, deepContains, firstFocusableElement, forwardFocus, indexOfItemContainingTarget, ownEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyChildNodes\", function() { return applyChildNodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closestFocusableAncestor\", function() { return closestFocusableAncestor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deepContains\", function() { return deepContains; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"firstFocusableElement\", function() { return firstFocusableElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forwardFocus\", function() { return forwardFocus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"indexOfItemContainingTarget\", function() { return indexOfItemContainingTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ownEvent\", function() { return ownEvent; });\n/* harmony import */ var _symbols_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbols.js */ \"./node_modules/elix/src/symbols.js\");\n\n\n\n/**\n * Miscellaneous utility functions for web components\n * \n * @module utilities\n */\n\nconst mousedownListenerKey = Symbol('mousedownListener');\n\n\n/**\n * Sets the element's `childNodes` to the given set of nodes.\n * \n * This adds or removes the element's `childNodes` as necessary to match the\n * nodes indicated in the `childNodes` parameter.\n * \n * @param {Node} element - the element to update\n * @param {(NodeList|Node[])} childNodes - the set of nodes to apply\n */\nfunction applyChildNodes(element, childNodes) {\n  // If the childNodes parameter is the actual childNodes of an element, then as\n  // we append those nodes to the indicated target element, they'll get removed\n  // from the original set. To keep the list stable, we make a copy.\n  const copy = [...childNodes];\n\n  const oldLength = element.childNodes.length;\n  const newLength = copy.length;\n  const length = Math.max(oldLength, newLength);\n  for (let i = 0; i < length; i++) {\n    const oldChild = element.childNodes[i];\n    const newChild = copy[i];\n    if (i >= oldLength) {\n      // Add new item not in old set.\n      element.appendChild(newChild);\n    } else if (i >= newLength) {\n      // Remove old item past end of new set.\n      element.removeChild(element.childNodes[newLength]);\n    } else if (oldChild !== newChild) {\n      if (copy.indexOf(oldChild, i) >= i) {\n        // Old node comes later in final set. Insert the new node rather than\n        // replacing it so that we don't detach the old node only to have to\n        // reattach it later.\n        element.insertBefore(newChild, oldChild);\n      } else {\n        // Replace old item with new item.\n        element.replaceChild(newChild, oldChild);\n      }\n    }\n  }\n}\n\n\n// Return the closest focusable ancestor in the *composed* tree.\n// If no focusable ancestor is found, returns null.\nfunction closestFocusableAncestor(element) {\n  // We want an element that has a tabIndex of 0 or more. We ignore disabled\n  // elements, and slot elements (which oddly have a tabIndex of 0).\n  if (element.tabIndex >= 0 && !element.disabled\n    && !(element instanceof HTMLSlotElement)) {\n    // Found an enabled component that wants the focus.\n    return element;\n  }\n  // If an element defines a focusTarget (e.g., via DelegateFocusMixin),\n  // see if that focusTarget is focusable at this point.\n  const focusTarget = element[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"focusTarget\"]];\n  if (focusTarget && focusTarget.tabIndex >= 0 && !focusTarget.disabled) {\n    return focusTarget;\n  }\n  // Not focusable; look higher in composed tree.\n  const parent = element.assignedSlot ?\n    element.assignedSlot :\n    // @ts-ignore\n    element.parentNode instanceof ShadowRoot ?\n      element.parentNode.host :\n      element.parentNode;\n  return parent ?\n    closestFocusableAncestor(parent) :\n    null;\n}\n\n\n /**\n * Returns true if the first node contains the second, even if the second node\n * is in a shadow tree.\n *\n * The standard Node.contains() function does not account for Shadow DOM, and\n * returns false if the supplied target node is sitting inside a shadow tree\n * within the container.\n * \n * @param {Node} container - The container to search within.\n * @param {Node} target - The node that may be inside the container.\n * @returns {boolean} - True if the container contains the target node.\n */\nfunction deepContains(container, target) {\n  /** @type {any} */\n  let current = target;\n  while (current) {\n    const parent = current.assignedSlot || current.parentNode || current.host;\n    if (parent === container) {\n      return true;\n    }\n    current = parent;\n  }\n  return false;\n}\n\n\n/**\n * Return the first focusable element in the composed tree below the given root.\n * The composed tree includes nodes assigned to slots.\n *\n * This heuristic considers only the document order of the elements below the\n * root and whether a given element is focusable. It currently does not respect\n * the tab sort order defined by tabindex values greater than zero.\n * \n * @param {HTMLElement} root - the root of the tree in which to search\n * @returns {HTMLElement|null} - the first focusable element, or null if none\n * was found\n */\nfunction firstFocusableElement(root) {\n  // CSS selectors for focusable elements from\n  // https://stackoverflow.com/a/30753870/76472\n  const focusableQuery = 'a[href],area[href],button:not([disabled]),details,iframe,input:not([disabled]),select:not([disabled]),textarea:not([disabled]),[contentEditable=\"true\"],[tabindex]';\n  // Walk the tree looking for nodes that match the above selectors.\n  const walker = walkComposedTree(root, node =>\n    node instanceof HTMLElement && \n    node.matches(focusableQuery) &&\n    node.tabIndex >= 0\n  );\n  // We only actually need the first matching value.\n  const { value } = walker.next();\n  // value, if defined, will always be an HTMLElement, but we do the following\n  // check to pass static type checking.\n  return value instanceof HTMLElement ?\n    value :\n    null;\n}\n\n\n/**\n * Trap any `mousedown` events on the `origin` element and prevent the default\n * behavior from setting the focus on that element. Instead, put the focus on\n * the `target` element (or, if the `target` is not focusable, on the target's\n * closest focusable ancestor).\n * \n * If this method is called again with the same `origin` element, the old\n * forwarding is overridden, and focus will now go to the new `target` element.\n * \n * If the `target` parameter is `null`, focus handling will be removed from the\n * indicated `origin`.\n * \n * @param {HTMLElement} origin\n * @param {HTMLElement|null} target\n */\nfunction forwardFocus(origin, target) {\n  if (origin[mousedownListenerKey]) {\n    // Origin was previously forwarding focus, probably to a different target.\n    // Remove the previous event listener.\n    origin.removeEventListener('mousedown', origin[mousedownListenerKey]);\n  }\n  if (target) {\n    origin[mousedownListenerKey] = (event) => {\n      // Only process events for the main (usually left) button.\n      if (event.button !== 0) {\n        return;\n      }\n      // What element wants the focus?\n      const desiredTarget = target[_symbols_js__WEBPACK_IMPORTED_MODULE_0__[\"focusTarget\"]] || target;\n      // What ancestor can actually take the focus?\n      const focusableTarget = closestFocusableAncestor(desiredTarget);\n      focusableTarget.focus();\n      event.preventDefault();  \n    };\n    origin.addEventListener('mousedown', origin[mousedownListenerKey]);\n  }\n}\n\n\n/**\n * Search a list element for the item that contains the specified target.\n * \n * When dealing with UI events (e.g., mouse clicks) that may occur in\n * subelements inside a list item, you can use this routine to obtain the\n * containing list item.\n * \n * @param {NodeList|Node[]} items - A list element containing a set of items\n * @param {Node} target - A target element that may or may not be an item in the\n * list.\n * @returns {number} - The index of the list child that is or contains the\n * indicated target node. Returns -1 if not found.\n */\nfunction indexOfItemContainingTarget(items, target) {\n  return Array.prototype.findIndex.call(items, item =>\n    item === target || deepContains(item, target)\n  );\n}\n\n\n/**\n * Return true if the event came from within the node (or from the node itself);\n * false otherwise.\n * \n * @param {Node} node - The node to consider in relation to the event\n * @param {Event} event - The event which may have been raised within/by the\n * node\n * @returns {boolean} - True if the event was raised within or by the node\n */\nfunction ownEvent(node, event) {\n  /** @type {any} */\n  const cast = event;\n  const eventSource = cast.composedPath()[0];\n  return node === eventSource || deepContains(node, eventSource);\n}\n\n\n// Walk the composed tree at the root for elements that pass the given filter.\nfunction* walkComposedTree(node, filter) {\n  if (filter(node)) {\n    yield node;\n  }\n  let children;\n  if (node.shadowRoot) {\n    // Walk the shadow instead of the light DOM.\n    children = node.shadowRoot.children;\n  } else {\n    const assignedNodes = node instanceof HTMLSlotElement ?\n      node.assignedNodes({ flatten: true }) :\n      [];\n    children = assignedNodes.length > 0 ?\n      // Walk light DOM nodes assigned to this slot.\n      assignedNodes :\n      // Walk light DOM children.\n      node.children;\n  }\n  if (children) {\n    for (let i = 0; i < children.length; i++) {\n      yield* walkComposedTree(children[i], filter);\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/elix/src/utilities.js?");

/***/ })

/******/ });